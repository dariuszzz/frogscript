type Person =
    age  int
    name string

fn square(arr [int]) -> [int] =
    let res = arr.util::map(util::square)

    return res

export fn plus1(arr [int]) -> int =
    let [int] res = arr
        .util::map(util::add1)

    return res

fn map_and_add(arr [int], f fn(int -> int), add int) -> int =
    let mapped = util::map(arr, f)
    let mapped = util::map(mapped, fn(x) return x + add)
    return mapped

fn main =
    map_and_add(
        [1, 2, 3],
        fn(x) 
            let square = x * x
            return square,
        2
    )
    .util::print()

    let [int] arr1 = square([1, 2, 3, 4, 5])
    util::print(arr1)
    
    let arr2 = plus1([1, 2, 3, 4, 5])
    arr2.util::print()

    arr2.util::map(fn(x) return x * x, 2)
        .util::print()
        
    let util::Printable something_that_can_be_printed = ...

    let people = [
        Person { age: 10, name: "Marque" },
        Person { age: 14, name: "Marc" },
        Person { age: 93, name: "Mark" },
    ]

    let fn(Person -> string) person_lambda = fn(person) 
        return util::to_string(person.age) + " - " + person.name

    for person Person in people:
        let str = person_lambda(person)
        util::print(str)

    // util::main()

/*
maybe new syntax

// This seems better since you usually change the arg name with some ide functionality
// while you change the type manually
// putting the type before func name and foo does seem kind of inconsistent though

let fn([int] -> ()) lambda = 
    fn(x) for y in x: util::print(y * 2)

let fn(int, int -> int) mul = fn(x int, y int) -> int x * y
let mul = fn(x int, y int) -> int x * y
let mul = fn(x int, y int) x * y
let mul = fn(x y) x * y
let mul = fn(_) $1 * $2

let implicit_arg = fn(ctx Context)(_) Context::multiply(ctx, $1 * $2)
let fn(Context)(int, int) implicit_arg = 
    fn(ctx)(_) Context::multiply(ctx, $1 * $2)

let multiline = fn(x, y)
    let foo = x * y
    return foo

let multiline = fn(x int, y int) -> int
    let foo = x * y
    return foo

let multiline = fn(_)
    let foo = $1 * $2
    return foo

func_that_takes_lambda(
    arg1,
    fn(_)
        let foo = $1 * $2
        return foo,
    arg3
)

func_that_takes_lambda(arg1, fn(_) $1 * $2, arg3)

*/